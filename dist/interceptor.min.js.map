{
  "version": 3,
  "file": "interceptor.min.js",
  "names": [],
  "mappings": "",
  "sources": [
    "interceptor.min.js"
  ],
  "sourcesContent": [
    "\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require, exports, module);\n  } else {\n    root.Interceptor = factory();\n  }\n}(this, function(require, exports, module) {\n\nreturn function __interceptor() {\n  'use strict';\n\n  var interceptors = [];\n  var apiInterceptors;\n\n  // This function checks if a value was intercepted and will be used to determine if a value has been modified\n  // by an interceptor.\n  function valueIsIntercepted(value) {\n    return value !== undefined;\n  }\n\n  // This function is used by Array.reduce in order to find the last element in an array that was modified by an\n  // interceptor. This is important for interceptor chaining.\n  function lastInterceptedValue(previous, current) {\n    return valueIsIntercepted(current) ? current : previous;\n  }\n\n  // This is a very simple JSON generator that sanitizes circular references\n  function flatten(s, stack) {\n    if(s === undefined || s === null || (typeof s === 'number' && isNaN(s))) {\n      return 'null';\n    } else if(s instanceof Date) {\n      return flatten(s.toJSON(), stack);\n    } else if(typeof s === 'object') {\n      stack = stack ? {obj: s, parent: stack} : {obj: s};\n\n      if((function cyclic(obj, stack, found) {\n        return found ||\n          (stack.parent ? cyclic(obj, stack.parent, stack.parent.obj === obj) : false);\n      }(s, stack))) {\n        return flatten('[circular reference]');\n      } else if(s instanceof Array) {\n        return ['[', s.map(function(v) {\n          return flatten(v, stack);\n        }).join(','), ']'].join('');\n      } else {\n        return ['{', Object.keys(s).filter(function(key) {\n          return s[key] !== undefined;\n        }).map(function(key) {\n          return ['\"', key, '\"', ':', flatten(s[key], stack)].join('');\n        }).join(','), '}'].join('');\n      }\n    } else if (typeof s === 'string') {\n      return ['\"', s, '\"'].join('');\n    } else {\n      return s;\n    }\n  }\n\n  function filterObjectProperties(object, filteredKeys) {\n    return filteredKeys.reduce(function(filteredObject, key) {\n      if(object.hasOwnProperty(key)) {\n        filteredObject[key] = object[key];\n      }\n      return filteredObject;\n    }, {});\n  }\n\n  // Checks if all properties of A exist in B and do match\n  // TODO: Check if JSON compare is the best option here\n  function objectsAreEqual(a, b, filteredKeys) {\n    if(filteredKeys) {\n      a = filterObjectProperties(a, filteredKeys);\n      b = filterObjectProperties(b, filteredKeys);\n    }\n\n    return flatten(a) === flatten(b);\n  }\n\n  function iterableToArray(iterable) {\n    var arr = [];\n    for(var i = 0, l = iterable.length; i < l; i++) {\n      arr.push(iterable[i]);\n    }\n    return arr;\n  }\n\n  // Function factory to create a compound interceptor function that works with descriptor selectors\n  // If an interception descriptor matches one of the added selective interceptor descriptors then\n  // the interception is delegated to the compound interceptor.\n  // This factory is used mainly for the API interceptor to provide the fluent API\n  function selectiveCompoundInterceptorFactory() {\n    var selectiveCompoundInterceptors = [];\n\n    return {\n      selectiveCompoundInterceptor: function selectiveCompoundInterceptor(descriptor) {\n\n        return selectiveCompoundInterceptors.filter(function (selectiveInterceptor) {\n          // First filter only interceptors where the descriptor matches using the isIn filter\n          return objectsAreEqual(selectiveInterceptor.descriptor, descriptor, Object.keys(selectiveInterceptor.descriptor));\n        }).map(function (selectiveInterceptor) {\n          // After we have filtered the interceptors we execute as a compound interceptor\n          // by calling each selective interceptor with the descriptor and reducing to the\n          // last intercepted value\n          return selectiveInterceptor.interceptor(descriptor);\n        }).reduce(lastInterceptedValue, undefined);\n      },\n      addSelectiveInterceptor: function (descriptor, interceptor) {\n        var selectiveInterceptor = {\n          descriptor: descriptor,\n          interceptor: interceptor\n        };\n\n        selectiveCompoundInterceptors.push(selectiveInterceptor);\n        return selectiveInterceptor;\n      },\n      removeSelectiveInterceptor: function (selectiveInterceptor) {\n        var index = selectiveCompoundInterceptors.indexOf(selectiveInterceptor);\n        if (index > -1) {\n          selectiveCompoundInterceptors.splice(index, 1);\n        }\n      }\n    };\n  }\n\n  apiInterceptors = selectiveCompoundInterceptorFactory();\n  // Add our apiInterceptors (selective compound interceptor) to the interceptors array as a fixed first interceptor\n  interceptors.push(apiInterceptors.selectiveCompoundInterceptor);\n\n  function createProxy(obj) {\n    // This object will be the proxy that we return\n    var proxy = {};\n    // Define a property that links to the original object\n    Object.defineProperty(proxy, '@@proxyOf', {\n      enumberable: false,\n      writable: false,\n      value: obj\n    });\n\n    Object.keys(obj).forEach(function (key) {\n\n      if (typeof obj[key] === 'function') {\n\n        // Define accessor properties for function proxy\n        Object.defineProperty(proxy, key, {\n          enumerable: true,\n          get: function () {\n            return function () {\n              var intercepted,\n                args = iterableToArray(arguments);\n\n              // Call every interceptor and return last one with valid return value (not undefined)\n              intercepted = interceptors.map(function (interceptor) {\n                return interceptor({\n                  object: obj,\n                  fn: key,\n                  type: 'invoke',\n                  args: args\n                });\n              }).reduce(lastInterceptedValue, undefined);\n\n              if (valueIsIntercepted(intercepted)) {\n                // Invocation should be intercepted so we return the intercepted value\n                return intercepted;\n              } else {\n                // The invokation was not intercetped so we will invoke the original function and\n                // check if the return value should be intercepted.\n                var returnValue = obj[key].apply(obj, arguments);\n\n                // Call every interceptor and return last one with valid return value (not undefined)\n                intercepted = interceptors.map(function (interceptor) {\n                  return interceptor({\n                    object: obj,\n                    fn: key,\n                    type: 'return',\n                    args: args,\n                    value: returnValue\n                  });\n                }).reduce(lastInterceptedValue, undefined);\n\n                return intercepted || returnValue;\n              }\n            };\n          },\n          set: function () {\n          }\n        });\n\n      } else {\n\n        // If the property is an object we create a proxy recursively\n        var objectPropertyProxy = typeof obj[key] === 'object' ? createProxy(obj[key]) : null;\n\n        // Define accessor properties that will call our interceptor callback\n        Object.defineProperty(proxy, key, {\n          enumerable: true,\n          get: function () {\n            var intercepted = interceptors.map(function (interceptor) {\n              return interceptor({\n                object: obj,\n                property: key,\n                type: 'get',\n                value: obj[key]\n              });\n            }).reduce(lastInterceptedValue, undefined);\n\n            if (valueIsIntercepted(intercepted)) {\n              return intercepted;\n            } else if (objectPropertyProxy) {\n              return objectPropertyProxy;\n            } else {\n              return obj[key];\n            }\n          },\n          set: function (value) {\n            var intercepted = interceptors.map(function (interceptor) {\n              return interceptor({\n                object: obj,\n                property: key,\n                type: 'set',\n                value: obj[key],\n                newValue: value\n              });\n            }).reduce(lastInterceptedValue, undefined);\n\n            if (valueIsIntercepted(intercepted)) {\n              obj[key] = intercepted;\n            } else if (typeof value === 'object') {\n              obj[key] = objectPropertyProxy = createProxy(value);\n            } else {\n              obj[key] = value;\n            }\n          }\n        });\n      }\n    });\n\n    // As long as we can't observe new properties being added we just return a frozen proxy\n    return /*Object.freeze(*/proxy/*)*/;\n  }\n\n  return {\n    proxy: createProxy,\n    intercept: function (fn) {\n      interceptors.push(fn);\n    },\n    when: function (property) {\n      return {\n        of: function (obj) {\n\n          // If the specified object is a proxy we'll use the original object rather than the proxy to avoid stack\n          // overflow\n          if (obj['@@proxyOf']) {\n            obj = obj['@@proxyOf'];\n          }\n\n          // The 'then' function factory is used to add a selective interceptor to the api interceptors and\n          // return an object with a remove function that can be used to remove the selective interceptor again.\n          function thenFactory(descriptorSelector) {\n            return function (fn) {\n              var selectiveInterceptor = apiInterceptors.addSelectiveInterceptor(descriptorSelector, fn);\n\n              return {\n                remove: function remove() {\n                  apiInterceptors.removeSelectiveInterceptor(selectiveInterceptor);\n                }\n              };\n            };\n          }\n\n          if (typeof obj[property] === 'function') {\n            // Return function interception API interface\n            return {\n              isInvoked: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'invoke',\n                    fn: property\n                  })\n                };\n              },\n              isInvokedWith: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'invoke',\n                    fn: property,\n                    args: iterableToArray(arguments)\n                  })\n                };\n              },\n              returns: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'return',\n                    fn: property\n                  })\n                };\n              },\n              returnsWith: function (returnValue) {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'return',\n                    fn: property,\n                    value: returnValue\n                  })\n                };\n              }\n            };\n          } else {\n            // Return property accessor interception API\n            return {\n              isSet: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'set',\n                    property: property\n                  })\n                };\n              },\n              isSetTo: function (value) {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'set',\n                    property: property,\n                    newValue: value\n                  })\n                };\n              },\n              isAccessed: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'get',\n                    property: property\n                  })\n                };\n              }\n            };\n          }\n        }\n      };\n    }\n  };\n};\n\n}));\n"
  ],
  "sourceRoot": ""
}