{
  "version": 3,
  "file": "interceptor.min.js",
  "sources": [
    "interceptor.js"
  ],
  "names": [
    "root",
    "factory",
    "define",
    "amd",
    "exports",
    "module",
    "require",
    "Interceptor",
    "this",
    "valueIsIntercepted",
    "value",
    "undefined",
    "lastInterceptedValue",
    "previous",
    "current",
    "flatten",
    "s",
    "stack",
    "isNaN",
    "Date",
    "toJSON",
    "obj",
    "parent",
    "cyclic",
    "found",
    "Array",
    "map",
    "v",
    "join",
    "Object",
    "keys",
    "filter",
    "key",
    "filterObjectProperties",
    "object",
    "filteredKeys",
    "reduce",
    "filteredObject",
    "hasOwnProperty",
    "objectsAreEqual",
    "a",
    "b",
    "iterableToArray",
    "iterable",
    "arr",
    "i",
    "l",
    "length",
    "push",
    "selectiveCompoundInterceptorFactory",
    "selectiveCompoundInterceptors",
    "selectiveCompoundInterceptor",
    "descriptor",
    "selectiveInterceptor",
    "interceptor",
    "addSelectiveInterceptor",
    "removeSelectiveInterceptor",
    "index",
    "indexOf",
    "splice",
    "createProxy",
    "proxy",
    "defineProperty",
    "enumberable",
    "writable",
    "forEach",
    "enumerable",
    "get",
    "intercepted",
    "args",
    "arguments",
    "interceptors",
    "fn",
    "type",
    "returnValue",
    "apply",
    "set",
    "objectPropertyProxy",
    "property",
    "newValue",
    "seal",
    "apiInterceptors",
    "intercept",
    "when",
    "of",
    "thenFactory",
    "descriptorSelector",
    "remove",
    "isInvoked",
    "then",
    "isInvokedWith",
    "returns",
    "returnsWith",
    "isSet",
    "isSetTo",
    "isAccessed"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * interceptor-js - Small library to generate interception proxies\n * @author Gion Kunz\n * @version v0.0.2\n * @link https://github.com/gionkunz/interceptor-js\n * Free to use under the WTFPL license.\n * http://www.wtfpl.net/\n */\n\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require, exports, module);\n  } else {\n    root.Interceptor = factory();\n  }\n}(this, function(require, exports, module) {\n\nreturn function __interceptor() {\n  'use strict';\n\n  var interceptors = [];\n  var apiInterceptors;\n\n  // This function checks if a value was intercepted and will be used to determine if a value has been modified\n  // by an interceptor.\n  function valueIsIntercepted(value) {\n    return value !== undefined;\n  }\n\n  // This function is used by Array.reduce in order to find the last element in an array that was modified by an\n  // interceptor. This is important for interceptor chaining.\n  function lastInterceptedValue(previous, current) {\n    return valueIsIntercepted(current) ? current : previous;\n  }\n\n  // This is a very simple JSON generator that sanitizes circular references\n  function flatten(s, stack) {\n    if(s === undefined || s === null || (typeof s === 'number' && isNaN(s))) {\n      return 'null';\n    } else if(s instanceof Date) {\n      return flatten(s.toJSON(), stack);\n    } else if(typeof s === 'object') {\n      stack = stack ? {obj: s, parent: stack} : {obj: s};\n\n      if((function cyclic(obj, stack, found) {\n        return found ||\n          (stack.parent ? cyclic(obj, stack.parent, stack.parent.obj === obj) : false);\n      }(s, stack))) {\n        return flatten('[circular reference]');\n      } else if(s instanceof Array) {\n        return ['[', s.map(function(v) {\n          return flatten(v, stack);\n        }).join(','), ']'].join('');\n      } else {\n        return ['{', Object.keys(s).filter(function(key) {\n          return s[key] !== undefined;\n        }).map(function(key) {\n          return ['\"', key, '\"', ':', flatten(s[key], stack)].join('');\n        }).join(','), '}'].join('');\n      }\n    } else if (typeof s === 'string') {\n      return ['\"', s, '\"'].join('');\n    } else {\n      return s;\n    }\n  }\n\n  function filterObjectProperties(object, filteredKeys) {\n    return filteredKeys.reduce(function(filteredObject, key) {\n      if(object.hasOwnProperty(key)) {\n        filteredObject[key] = object[key];\n      }\n      return filteredObject;\n    }, {});\n  }\n\n  // Checks if all properties of A exist in B and do match\n  // TODO: Check if JSON compare is the best option here\n  function objectsAreEqual(a, b, filteredKeys) {\n    if(filteredKeys) {\n      a = filterObjectProperties(a, filteredKeys);\n      b = filterObjectProperties(b, filteredKeys);\n    }\n\n    return flatten(a) === flatten(b);\n  }\n\n  function iterableToArray(iterable) {\n    var arr = [];\n    for(var i = 0, l = iterable.length; i < l; i++) {\n      arr.push(iterable[i]);\n    }\n    return arr;\n  }\n\n  // Function factory to create a compound interceptor function that works with descriptor selectors\n  // If an interception descriptor matches one of the added selective interceptor descriptors then\n  // the interception is delegated to the compound interceptor.\n  // This factory is used mainly for the API interceptor to provide the fluent API\n  function selectiveCompoundInterceptorFactory() {\n    var selectiveCompoundInterceptors = [];\n\n    return {\n      selectiveCompoundInterceptor: function selectiveCompoundInterceptor(descriptor) {\n\n        return selectiveCompoundInterceptors.filter(function (selectiveInterceptor) {\n          // First filter only interceptors where the descriptor matches using the isIn filter\n          return objectsAreEqual(selectiveInterceptor.descriptor, descriptor, Object.keys(selectiveInterceptor.descriptor));\n        }).map(function (selectiveInterceptor) {\n          // After we have filtered the interceptors we execute as a compound interceptor\n          // by calling each selective interceptor with the descriptor and reducing to the\n          // last intercepted value\n          return selectiveInterceptor.interceptor(descriptor);\n        }).reduce(lastInterceptedValue, undefined);\n      },\n      addSelectiveInterceptor: function (descriptor, interceptor) {\n        var selectiveInterceptor = {\n          descriptor: descriptor,\n          interceptor: interceptor\n        };\n\n        selectiveCompoundInterceptors.push(selectiveInterceptor);\n        return selectiveInterceptor;\n      },\n      removeSelectiveInterceptor: function (selectiveInterceptor) {\n        var index = selectiveCompoundInterceptors.indexOf(selectiveInterceptor);\n        if (index > -1) {\n          selectiveCompoundInterceptors.splice(index, 1);\n        }\n      }\n    };\n  }\n\n  apiInterceptors = selectiveCompoundInterceptorFactory();\n  // Add our apiInterceptors (selective compound interceptor) to the interceptors array as a fixed first interceptor\n  interceptors.push(apiInterceptors.selectiveCompoundInterceptor);\n\n  function createProxy(obj) {\n    // This object will be the proxy that we return\n    var proxy = {};\n    // Define a property that links to the original object\n    Object.defineProperty(proxy, '@@proxyOf', {\n      enumberable: false,\n      writable: false,\n      value: obj\n    });\n\n    Object.keys(obj).forEach(function (key) {\n\n      if (typeof obj[key] === 'function') {\n\n        // Define accessor properties for function proxy\n        Object.defineProperty(proxy, key, {\n          enumerable: true,\n          get: function () {\n            return function () {\n              var intercepted,\n                args = iterableToArray(arguments);\n\n              // Call every interceptor and return last one with valid return value (not undefined)\n              intercepted = interceptors.map(function (interceptor) {\n                return interceptor({\n                  object: obj,\n                  fn: key,\n                  type: 'invoke',\n                  args: args\n                });\n              }).reduce(lastInterceptedValue, undefined);\n\n              if (valueIsIntercepted(intercepted)) {\n                // Invocation should be intercepted so we return the intercepted value\n                return intercepted;\n              } else {\n                // The invokation was not intercetped so we will invoke the original function and\n                // check if the return value should be intercepted.\n                var returnValue = obj[key].apply(obj, arguments);\n\n                // Call every interceptor and return last one with valid return value (not undefined)\n                intercepted = interceptors.map(function (interceptor) {\n                  return interceptor({\n                    object: obj,\n                    fn: key,\n                    type: 'return',\n                    args: args,\n                    value: returnValue\n                  });\n                }).reduce(lastInterceptedValue, undefined);\n\n                return intercepted || returnValue;\n              }\n            };\n          },\n          set: function () {\n          }\n        });\n\n      } else {\n\n        // If the property is an object we create a proxy recursively\n        var objectPropertyProxy = typeof obj[key] === 'object' ? createProxy(obj[key]) : null;\n\n        // Define accessor properties that will call our interceptor callback\n        Object.defineProperty(proxy, key, {\n          enumerable: true,\n          get: function () {\n            var intercepted = interceptors.map(function (interceptor) {\n              return interceptor({\n                object: obj,\n                property: key,\n                type: 'get',\n                value: obj[key]\n              });\n            }).reduce(lastInterceptedValue, undefined);\n\n            if (valueIsIntercepted(intercepted)) {\n              return intercepted;\n            } else if (objectPropertyProxy) {\n              return objectPropertyProxy;\n            } else {\n              return obj[key];\n            }\n          },\n          set: function (value) {\n            var intercepted = interceptors.map(function (interceptor) {\n              return interceptor({\n                object: obj,\n                property: key,\n                type: 'set',\n                value: obj[key],\n                newValue: value\n              });\n            }).reduce(lastInterceptedValue, undefined);\n\n            if (valueIsIntercepted(intercepted)) {\n              obj[key] = intercepted;\n            } else if (typeof value === 'object') {\n              obj[key] = objectPropertyProxy = createProxy(value);\n            } else {\n              obj[key] = value;\n            }\n          }\n        });\n      }\n    });\n\n    // As long as we can't observe new properties being added we just return a sealed proxy\n    return Object.seal(proxy);\n  }\n\n  return {\n    proxy: createProxy,\n    intercept: function (fn) {\n      interceptors.push(fn);\n    },\n    when: function (property) {\n      return {\n        of: function (obj) {\n\n          // If the specified object is a proxy we'll use the original object rather than the proxy to avoid stack\n          // overflow\n          if (obj['@@proxyOf']) {\n            obj = obj['@@proxyOf'];\n          }\n\n          // The 'then' function factory is used to add a selective interceptor to the api interceptors and\n          // return an object with a remove function that can be used to remove the selective interceptor again.\n          function thenFactory(descriptorSelector) {\n            return function (fn) {\n              var selectiveInterceptor = apiInterceptors.addSelectiveInterceptor(descriptorSelector, fn);\n\n              return {\n                remove: function remove() {\n                  apiInterceptors.removeSelectiveInterceptor(selectiveInterceptor);\n                }\n              };\n            };\n          }\n\n          if (typeof obj[property] === 'function') {\n            // Return function interception API interface\n            return {\n              isInvoked: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'invoke',\n                    fn: property\n                  })\n                };\n              },\n              isInvokedWith: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'invoke',\n                    fn: property,\n                    args: iterableToArray(arguments)\n                  })\n                };\n              },\n              returns: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'return',\n                    fn: property\n                  })\n                };\n              },\n              returnsWith: function (returnValue) {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'return',\n                    fn: property,\n                    value: returnValue\n                  })\n                };\n              }\n            };\n          } else {\n            // Return property accessor interception API\n            return {\n              isSet: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'set',\n                    property: property\n                  })\n                };\n              },\n              isSetTo: function (value) {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'set',\n                    property: property,\n                    newValue: value\n                  })\n                };\n              },\n              isAccessed: function () {\n                return {\n                  then: thenFactory({\n                    object: obj,\n                    type: 'get',\n                    property: property\n                  })\n                };\n              }\n            };\n          }\n        }\n      };\n    }\n  };\n};\n\n}));\n"
  ],
  "sourceRoot": ""
}